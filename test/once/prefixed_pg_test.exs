defmodule Once.PrefixedPgTest do
  use TestOnce.DataCase, async: true

  alias MyApp.{PgRepo, PrefixSchema}
  import Ecto.Query

  @range Integer.pow(2, 64)
  @signed_min -Integer.pow(2, 63)
  @signed_max Integer.pow(2, 63) - 1
  @unsigned_max @range - 1

  defp get_raw() do
    from(r in "test_table",
      select: [:autogenerated, :bin_id, :bigint_id, :string_id]
    )
  end

  defp get_raw(field, value), do: get_raw() |> by_field(field, value)

  defp get(field, value) do
    from(r in PrefixSchema) |> by_field(field, value)
  end

  defp by_field(query, field, value), do: where(query, [a], field(a, ^field) == ^value)

  describe "autogenerated" do
    test "can be autogenerated" do
      assert {:ok, inserted} = PrefixSchema.changeset(%{}) |> PgRepo.insert()
      assert <<"t_", _::88>> = inserted.autogenerated
      res = get_raw() |> PgRepo.one()
      assert is_integer(res.autogenerated)
    end
  end

  describe "bigint type" do
    test "correctly returns input" do
      for {input, expected, expected_raw} <- [
            {"t_0", "t_0", 0},
            {"t_#{@signed_min}", "t_#{@signed_min}", @signed_min},
            {"t_#{@signed_max}", "t_#{@signed_max}", @signed_max},
            {"t_#{@unsigned_max}", "t_-1", -1}
          ] do
        assert {:ok, inserted} = PrefixSchema.changeset(%{bigint_id: input}) |> PgRepo.insert()
        assert expected == inserted.bigint_id
        assert %{} = get_raw(:bigint_id, expected_raw) |> PgRepo.one()
        assert %{bigint_id: ^expected} = get(:bigint_id, expected) |> PgRepo.one()
      end
    end

    test "accepts prefixed numeric string input" do
      assert {:ok, inserted} = PrefixSchema.changeset(%{bigint_id: "t_0"}) |> PgRepo.insert()
      assert "t_0" == inserted.bigint_id
      assert %{bigint_id: 0} = get_raw() |> PgRepo.one()
    end
  end

  describe "bin type" do
    test "correctly returns input" do
      for {input, expected, expected_raw} <- [
            {"t_AAAAAAAAAAA", "t_AAAAAAAAAAA", <<0, 0, 0, 0, 0, 0, 0, 0>>},
            {"t_gAAAAAAAAAA", "t_gAAAAAAAAAA", <<128, 0, 0, 0, 0, 0, 0, 0>>},
            {"t_f_________8", "t_f_________8", <<127, 255, 255, 255, 255, 255, 255, 255>>},
            {"t___________8", "t___________8", <<255, 255, 255, 255, 255, 255, 255, 255>>}
          ] do
        assert {:ok, inserted} = PrefixSchema.changeset(%{bin_id: input}) |> PgRepo.insert()
        assert expected == inserted.bin_id
        assert %{} = get_raw(:bin_id, expected_raw) |> PgRepo.one()
        assert %{bin_id: ^expected} = get(:bin_id, expected) |> PgRepo.one()
      end
    end

    test "accepts prefixed input" do
      assert {:ok, inserted} =
               PrefixSchema.changeset(%{bin_id: "t_AAAAAAAAAAA"}) |> PgRepo.insert()

      assert "t_AAAAAAAAAAA" == inserted.bin_id
      assert %{bin_id: <<0, 0, 0, 0, 0, 0, 0, 0>>} = get_raw() |> PgRepo.one()
    end
  end

  describe "string type with persist_prefix" do
    test "correctly returns input and persists prefix" do
      for {input, expected, expected_raw} <- [
            {"t_AAAAAAAAAAA", "t_AAAAAAAAAAA", "t_AAAAAAAAAAA"},
            {"t_gAAAAAAAAAA", "t_gAAAAAAAAAA", "t_gAAAAAAAAAA"},
            {"t_f_________8", "t_f_________8", "t_f_________8"},
            {"t___________8", "t___________8", "t___________8"}
          ] do
        assert {:ok, inserted} = PrefixSchema.changeset(%{string_id: input}) |> PgRepo.insert()
        assert expected == inserted.string_id
        assert %{} = get_raw(:string_id, expected_raw) |> PgRepo.one()
        assert %{string_id: ^expected} = get(:string_id, expected) |> PgRepo.one()
      end
    end

    test "accepts prefixed input" do
      assert {:ok, inserted} =
               PrefixSchema.changeset(%{string_id: "t_AAAAAAAAAAA"}) |> PgRepo.insert()

      assert "t_AAAAAAAAAAA" == inserted.string_id
      assert %{string_id: "t_AAAAAAAAAAA"} = get_raw() |> PgRepo.one()
    end

    test "persists prefix in database" do
      {:ok, _} = PrefixSchema.changeset(%{string_id: "t_AAAAAAAAAAA"}) |> PgRepo.insert()

      # Query raw database - should have prefix stored
      result = PgRepo.one(from r in "test_table", select: r.string_id, limit: 1)
      assert <<"t_", _::binary>> = result
    end

    test "rejects loading non-prefixed value when persist_prefix is true" do
      # Manually insert unprefixed value into database
      PgRepo.query!("INSERT INTO test_table (string_id) VALUES ($1)", ["AAAAAAAAAAA"])

      # Attempting to load should fail due to missing prefix
      assert_raise ArgumentError, ~r/cannot load/, fn ->
        PgRepo.one(from s in PrefixSchema, select: s.string_id, limit: 1)
      end
    end
  end

  describe "query by value" do
    test "querying with prefixed value works for non-persisted prefix" do
      {:ok, _} = PrefixSchema.changeset(%{bigint_id: "t_123"}) |> PgRepo.insert()

      # Query using prefixed value should work
      assert %{bigint_id: "t_123"} = get(:bigint_id, "t_123") |> PgRepo.one()
    end

    test "querying with unprefixed value fails for non-persisted prefix" do
      {:ok, _} = PrefixSchema.changeset(%{bigint_id: "t_123"}) |> PgRepo.insert()

      # Query using unprefixed value should fail with cast error
      assert_raise Ecto.Query.CastError, ~r/cannot be cast/, fn ->
        get(:bigint_id, "123") |> PgRepo.one()
      end
    end

    test "querying with prefixed value works for persisted prefix" do
      {:ok, _} = PrefixSchema.changeset(%{string_id: "t_AAAAAAAAAAA"}) |> PgRepo.insert()

      # Query using prefixed value should work
      assert %{string_id: "t_AAAAAAAAAAA"} = get(:string_id, "t_AAAAAAAAAAA") |> PgRepo.one()
    end

    test "querying with unprefixed value fails for persisted prefix" do
      {:ok, _} = PrefixSchema.changeset(%{string_id: "t_AAAAAAAAAAA"}) |> PgRepo.insert()

      # Query using unprefixed value should fail with cast error
      assert_raise Ecto.Query.CastError, ~r/cannot be cast/, fn ->
        get(:string_id, "AAAAAAAAAAA") |> PgRepo.one()
      end
    end

    test "querying database directly with raw value works for non-persisted prefix" do
      {:ok, _} = PrefixSchema.changeset(%{bigint_id: "t_123"}) |> PgRepo.insert()

      # Query raw database - should be stored without prefix
      assert %{bigint_id: 123} = get_raw(:bigint_id, 123) |> PgRepo.one()
    end

    test "querying database directly with raw value works for persisted prefix" do
      {:ok, _} = PrefixSchema.changeset(%{string_id: "t_AAAAAAAAAAA"}) |> PgRepo.insert()

      # Query raw database - should be stored with prefix
      assert %{string_id: "t_AAAAAAAAAAA"} = get_raw(:string_id, "t_AAAAAAAAAAA") |> PgRepo.one()
    end
  end

  describe "raw binary format with prefix" do
    test "raw format stores binary with prefix bytes when persist_prefix is false" do
      {:ok, inserted} = PrefixSchema.changeset(%{bin_id: "t_AAAAAAAAAAA"}) |> PgRepo.insert()

      # Elixir value should have text prefix
      assert <<"t_", _::88>> = inserted.bin_id

      # Database should have pure binary without prefix
      raw = PgRepo.one(from r in "test_table", select: r.bin_id, limit: 1)
      assert <<0, 0, 0, 0, 0, 0, 0, 0>> = raw
      refute String.starts_with?(raw, "t_")
    end

    test "raw format round-trip preserves prefix in Elixir" do
      url64_value = "t_AAAAAAAAAAA"
      {:ok, inserted} = PrefixSchema.changeset(%{bin_id: url64_value}) |> PgRepo.insert()

      # Load from database
      loaded = PgRepo.one(from s in PrefixSchema, where: s.id == ^inserted.id, select: s.bin_id)

      # Should have prefix restored
      assert <<"t_", _::88>> = loaded
      assert loaded == url64_value
    end

    test "raw format binary structure is correct" do
      # Insert value that decodes to known bytes
      {:ok, _} = PrefixSchema.changeset(%{bin_id: "t_f_________8"}) |> PgRepo.insert()

      # Check raw database value
      raw = PgRepo.one(from r in "test_table", select: r.bin_id, limit: 1)
      assert <<127, 255, 255, 255, 255, 255, 255, 255>> = raw
    end
  end
end
