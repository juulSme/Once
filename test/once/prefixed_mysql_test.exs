defmodule Once.PrefixedMysqlTest do
  use TestOnce.DataCase, async: true

  alias MyApp.{MysqlRepo, PrefixSchema}
  import Ecto.Query

  @range Integer.pow(2, 64)
  @signed_min -Integer.pow(2, 63)
  @signed_max Integer.pow(2, 63) - 1
  @unsigned_max @range - 1

  defp get_raw() do
    from(r in "test_table",
      select: [:autogenerated, :bin_id, :bigint_id, :string_id, :unsigned_id]
    )
  end

  defp get_raw(field, value), do: get_raw() |> by_field(field, value)

  defp get(field, value) do
    from(r in PrefixSchema, select_merge: %{unsigned_id: r.unsigned_id}) |> by_field(field, value)
  end

  defp by_field(query, field, value), do: where(query, [a], field(a, ^field) == ^value)

  describe "autogenerated" do
    test "can be autogenerated" do
      assert {:ok, inserted} = PrefixSchema.changeset(%{}) |> MysqlRepo.insert()
      assert <<"t_", _::88>> = inserted.autogenerated
      res = get_raw() |> MysqlRepo.one()
      assert is_integer(res.autogenerated)
    end
  end

  describe "bigint type" do
    test "correctly returns input" do
      for {input, expected, expected_raw} <- [
            {"t_0", "t_0", 0},
            {"t_#{@signed_min}", "t_#{@signed_min}", @signed_min},
            {"t_#{@signed_max}", "t_#{@signed_max}", @signed_max},
            {"t_#{@unsigned_max}", "t_-1", -1}
          ] do
        assert {:ok, inserted} = PrefixSchema.changeset(%{bigint_id: input}) |> MysqlRepo.insert()
        assert expected == inserted.bigint_id
        assert %{} = get_raw(:bigint_id, expected_raw) |> MysqlRepo.one()
        assert %{bigint_id: ^expected} = get(:bigint_id, expected) |> MysqlRepo.one()
      end
    end

    test "accepts prefixed numeric string input" do
      assert {:ok, inserted} = PrefixSchema.changeset(%{bigint_id: "t_0"}) |> MysqlRepo.insert()
      assert "t_0" == inserted.bigint_id
      assert %{bigint_id: 0} = get_raw() |> MysqlRepo.one()
    end
  end

  describe "bin type" do
    test "correctly returns input" do
      for {input, expected, expected_raw} <- [
            {"t_AAAAAAAAAAA", "t_AAAAAAAAAAA", <<0, 0, 0, 0, 0, 0, 0, 0>>},
            {"t_gAAAAAAAAAA", "t_gAAAAAAAAAA", <<128, 0, 0, 0, 0, 0, 0, 0>>},
            {"t_f_________8", "t_f_________8", <<127, 255, 255, 255, 255, 255, 255, 255>>},
            {"t___________8", "t___________8", <<255, 255, 255, 255, 255, 255, 255, 255>>}
          ] do
        assert {:ok, inserted} = PrefixSchema.changeset(%{bin_id: input}) |> MysqlRepo.insert()
        assert expected == inserted.bin_id
        assert %{} = get_raw(:bin_id, expected_raw) |> MysqlRepo.one()
        assert %{bin_id: ^expected} = get(:bin_id, expected) |> MysqlRepo.one()
      end
    end

    test "accepts prefixed input" do
      assert {:ok, inserted} =
               PrefixSchema.changeset(%{bin_id: "t_AAAAAAAAAAA"}) |> MysqlRepo.insert()

      assert "t_AAAAAAAAAAA" == inserted.bin_id
      assert %{bin_id: <<0, 0, 0, 0, 0, 0, 0, 0>>} = get_raw() |> MysqlRepo.one()
    end
  end

  describe "string type with persist_prefix" do
    test "correctly returns input and persists prefix" do
      for {input, expected, expected_raw} <- [
            {"t_AAAAAAAAAAA", "t_AAAAAAAAAAA", "t_AAAAAAAAAAA"},
            {"t_gAAAAAAAAAA", "t_gAAAAAAAAAA", "t_gAAAAAAAAAA"},
            {"t_f_________8", "t_f_________8", "t_f_________8"},
            {"t___________8", "t___________8", "t___________8"}
          ] do
        assert {:ok, inserted} = PrefixSchema.changeset(%{string_id: input}) |> MysqlRepo.insert()
        assert expected == inserted.string_id
        assert %{} = get_raw(:string_id, expected_raw) |> MysqlRepo.one()
        assert %{string_id: ^expected} = get(:string_id, expected) |> MysqlRepo.one()
      end
    end

    test "accepts prefixed input" do
      assert {:ok, inserted} =
               PrefixSchema.changeset(%{string_id: "t_AAAAAAAAAAA"}) |> MysqlRepo.insert()

      assert "t_AAAAAAAAAAA" == inserted.string_id
      assert %{string_id: "t_AAAAAAAAAAA"} = get_raw() |> MysqlRepo.one()
    end

    test "persists prefix in database" do
      {:ok, _} = PrefixSchema.changeset(%{string_id: "t_AAAAAAAAAAA"}) |> MysqlRepo.insert()

      # Query raw database - should have prefix stored
      result = MysqlRepo.one(from r in "test_table", select: r.string_id, limit: 1)
      assert <<"t_", _::binary>> = result
    end

    test "rejects loading non-prefixed value when persist_prefix is true" do
      # Manually insert unprefixed value into database
      MysqlRepo.query!("INSERT INTO test_table (string_id) VALUES (?)", ["AAAAAAAAAAA"])

      # Attempting to load should fail due to missing prefix
      assert_raise ArgumentError, ~r/cannot load/, fn ->
        MysqlRepo.one(from s in PrefixSchema, select: s.string_id, limit: 1)
      end
    end
  end

  describe "unsigned bigint type" do
    test "correctly returns input" do
      for {input, expected, expected_raw} <- [
            {"t_AAAAAAAAAAA", "t_AAAAAAAAAAA", 0},
            {"t_gAAAAAAAAAA", "t_gAAAAAAAAAA", @signed_max + 1},
            {"t_f_________8", "t_f_________8", @signed_max},
            {"t___________8", "t___________8", @unsigned_max}
          ] do
        assert {:ok, inserted} =
                 PrefixSchema.changeset(%{unsigned_id: input}) |> MysqlRepo.insert()

        assert expected == inserted.unsigned_id
        assert %{} = get_raw(:unsigned_id, expected_raw) |> MysqlRepo.one()
        assert %{unsigned_id: ^expected} = get(:unsigned_id, expected) |> MysqlRepo.one()
      end
    end

    test "accepts prefixed url64 input" do
      assert {:ok, inserted} =
               PrefixSchema.changeset(%{unsigned_id: "t_AAAAAAAAAAA"}) |> MysqlRepo.insert()

      assert "t_AAAAAAAAAAA" == inserted.unsigned_id
      assert %{unsigned_id: 0} = get_raw() |> MysqlRepo.one()
    end

    test "handles full unsigned range correctly" do
      # Test boundary values for unsigned
      {:ok, max_val} =
        PrefixSchema.changeset(%{unsigned_id: "t___________8"}) |> MysqlRepo.insert()

      assert "t___________8" == max_val.unsigned_id

      # Verify raw storage
      assert %{unsigned_id: @unsigned_max} =
               get_raw(:unsigned_id, @unsigned_max) |> MysqlRepo.one()
    end

    test "converts between signed and unsigned correctly" do
      # Value that's negative in signed but positive in unsigned
      {:ok, inserted} =
        PrefixSchema.changeset(%{unsigned_id: "t_gAAAAAAAAAA"}) |> MysqlRepo.insert()

      # Should be stored as unsigned positive value
      raw = get_raw() |> MysqlRepo.one()
      assert raw.unsigned_id == @signed_max + 1

      # Should load back as the same url64 value
      assert inserted.unsigned_id == "t_gAAAAAAAAAA"
    end
  end

  describe "query by value" do
    test "querying with prefixed value works for non-persisted prefix" do
      {:ok, _} = PrefixSchema.changeset(%{bigint_id: "t_123"}) |> MysqlRepo.insert()

      # Query using prefixed value should work
      assert %{bigint_id: "t_123"} = get(:bigint_id, "t_123") |> MysqlRepo.one()
    end

    test "querying with unprefixed value fails for non-persisted prefix" do
      {:ok, _} = PrefixSchema.changeset(%{bigint_id: "t_123"}) |> MysqlRepo.insert()

      # Query using unprefixed value should fail with cast error
      assert_raise Ecto.Query.CastError, ~r/cannot be cast/, fn ->
        get(:bigint_id, "123") |> MysqlRepo.one()
      end
    end

    test "querying with prefixed value works for persisted prefix" do
      {:ok, _} = PrefixSchema.changeset(%{string_id: "t_AAAAAAAAAAA"}) |> MysqlRepo.insert()

      # Query using prefixed value should work
      assert %{string_id: "t_AAAAAAAAAAA"} = get(:string_id, "t_AAAAAAAAAAA") |> MysqlRepo.one()
    end

    test "querying with unprefixed value fails for persisted prefix" do
      {:ok, _} = PrefixSchema.changeset(%{string_id: "t_AAAAAAAAAAA"}) |> MysqlRepo.insert()

      # Query using unprefixed value should fail with cast error
      assert_raise Ecto.Query.CastError, ~r/cannot be cast/, fn ->
        get(:string_id, "AAAAAAAAAAA") |> MysqlRepo.one()
      end
    end

    test "querying database directly with raw value works for non-persisted prefix" do
      {:ok, _} = PrefixSchema.changeset(%{bigint_id: "t_123"}) |> MysqlRepo.insert()

      # Query raw database - should be stored without prefix
      assert %{bigint_id: 123} = get_raw(:bigint_id, 123) |> MysqlRepo.one()
    end

    test "querying database directly with raw value works for persisted prefix" do
      {:ok, _} = PrefixSchema.changeset(%{string_id: "t_AAAAAAAAAAA"}) |> MysqlRepo.insert()

      # Query raw database - should be stored with prefix
      assert %{string_id: "t_AAAAAAAAAAA"} =
               get_raw(:string_id, "t_AAAAAAAAAAA") |> MysqlRepo.one()
    end

    test "querying unsigned field with prefixed value works" do
      {:ok, _} = PrefixSchema.changeset(%{unsigned_id: "t_AAAAAAAAAAA"}) |> MysqlRepo.insert()

      # Query using prefixed value should work
      assert %{unsigned_id: "t_AAAAAAAAAAA"} =
               get(:unsigned_id, "t_AAAAAAAAAAA") |> MysqlRepo.one()
    end

    test "querying database directly for unsigned shows raw unsigned value" do
      {:ok, _} = PrefixSchema.changeset(%{unsigned_id: "t_gAAAAAAAAAA"}) |> MysqlRepo.insert()

      # Query raw database - should be stored as unsigned integer
      expected_unsigned = @signed_max + 1

      assert %{unsigned_id: ^expected_unsigned} =
               get_raw(:unsigned_id, expected_unsigned) |> MysqlRepo.one()
    end
  end

  describe "raw binary format with prefix" do
    test "raw format stores binary with prefix bytes when persist_prefix is false" do
      {:ok, inserted} = PrefixSchema.changeset(%{bin_id: "t_AAAAAAAAAAA"}) |> MysqlRepo.insert()

      # Elixir value should have text prefix
      assert <<"t_", _::88>> = inserted.bin_id

      # Database should have pure binary without prefix
      raw = MysqlRepo.one(from r in "test_table", select: r.bin_id, limit: 1)
      assert <<0, 0, 0, 0, 0, 0, 0, 0>> = raw
      refute String.starts_with?(raw, "t_")
    end

    test "raw format round-trip preserves prefix in Elixir" do
      url64_value = "t_AAAAAAAAAAA"
      {:ok, inserted} = PrefixSchema.changeset(%{bin_id: url64_value}) |> MysqlRepo.insert()

      # Load from database
      loaded =
        MysqlRepo.one(from s in PrefixSchema, where: s.id == ^inserted.id, select: s.bin_id)

      # Should have prefix restored
      assert <<"t_", _::88>> = loaded
      assert loaded == url64_value
    end

    test "raw format binary structure is correct" do
      # Insert value that decodes to known bytes
      {:ok, _} = PrefixSchema.changeset(%{bin_id: "t_f_________8"}) |> MysqlRepo.insert()

      # Check raw database value
      raw = MysqlRepo.one(from r in "test_table", select: r.bin_id, limit: 1)
      assert <<127, 255, 255, 255, 255, 255, 255, 255>> = raw
    end
  end
end
